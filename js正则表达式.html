<!DOCTYPE html>
<html lang="">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="js正则表达式">




  <meta name="keywords" content="js,">





  <link rel="alternate" href="/default" title="//:Anonymous Note">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1">



<link rel="canonical" href="http://lawlietcos.com/js正则表达式.html">


<meta name="description" content="ECMAScript中通过RegExp类型来支持正则表达式，  let expression = / pattern / flags ;  pattern是正则表达式，可以包含字符类、限定符、分组、向前查找、反向引用。 flags用以标明正则表达式的行为： g 表示全局模式，即模式将被应用于所有字符串，不会在发现第一个匹配项时立即停止 i 表示不区分大小写模式(case-insensitive">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="js正则表达式">
<meta property="og:url" content="http://lawlietcos.com/js正则表达式.html">
<meta property="og:site_name" content="&#x2F;&#x2F;:Anonymous Note">
<meta property="og:description" content="ECMAScript中通过RegExp类型来支持正则表达式，  let expression = / pattern / flags ;  pattern是正则表达式，可以包含字符类、限定符、分组、向前查找、反向引用。 flags用以标明正则表达式的行为： g 表示全局模式，即模式将被应用于所有字符串，不会在发现第一个匹配项时立即停止 i 表示不区分大小写模式(case-insensitive">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-02-20T11:37:29.993Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js正则表达式">
<meta name="twitter:description" content="ECMAScript中通过RegExp类型来支持正则表达式，  let expression = / pattern / flags ;  pattern是正则表达式，可以包含字符类、限定符、分组、向前查找、反向引用。 flags用以标明正则表达式的行为： g 表示全局模式，即模式将被应用于所有字符串，不会在发现第一个匹配项时立即停止 i 表示不区分大小写模式(case-insensitive">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  





  


    <title> js正则表达式 - //:Anonymous Note </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">//:Anonymous Note</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          js正则表达式
        
      </h1>

      <time class="post-time">
          Feb 20 2019
      </time>
    </header>



    
            <div class="post-content">
            <p>  ECMAScript中通过RegExp类型来支持正则表达式，<br>  let expression = / pattern / flags ;</p>
<ul>
<li>pattern是正则表达式，可以包含字符类、限定符、分组、向前查找、反向引用。</li>
<li>flags用以标明正则表达式的行为：<ul>
<li>g 表示全局模式，即模式将被应用于所有字符串，不会在发现第一个匹配项时立即停止</li>
<li>i 表示不区分大小写模式(case-insensitive)</li>
<li>m 多行查找</li>
</ul>
</li>
</ul>
<h1 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h1><ul>
<li>横向模糊匹配 {a， b} 表示连续出现至少a次，最多b次</li>
<li>纵向模糊匹配 [abc] 表示a, b, c中任意一个</li>
</ul>
<h1 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h1><ul>
<li>[abc] abc中任意一个</li>
<li><p>[a-z] 范围表示法，字母a到字母z</p>
<ul>
<li>特殊的要匹配”a”, “z”, “-“,则需要[-az]或者[az-]或者[a-z]</li>
</ul>
</li>
<li><p>[^abc] 排除字符组 表示不能是abc中任意一个</p>
</li>
</ul>
<h2 id="字符组的简写"><a href="#字符组的简写" class="headerlink" title="字符组的简写"></a>字符组的简写</h2><ul>
<li>\d  表示[0-9]，代表一个数字   (digit)</li>
<li>\D  表示[^0-9]</li>
<li>\w  表示[0-9a-zA-Z_]，表示数字，大小写字母和下划线 (word)</li>
<li>\W  表示[^0-9a-zA-Z_]</li>
<li>\s  表示[ \t\v\n\r\f]，表示空格，水平制表符，垂直制表符，换行符，回车符，换页符 (space)</li>
<li>\S  表示[^ \t\v\n\r\f]</li>
<li>.   表示[^\n\r\u2028\u2029]，通配符,除了换行符，回车符，行分隔符和段分隔符除外</li>
</ul>
<p>所以如果要匹配任意字符，可以使用[\d\D], [\w\W], [\s\S] 和 [^]</p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><ul>
<li>{m, }  表示至少出现m次</li>
<li>{m}    等价于{m, m}，表示出现m次</li>
<li>?      等价于{0, 1}, 表示出现或者不出现</li>
<li>+      等价于{1, },表示至少出现一次</li>
<li>×      等价于{0, },表示出现任意次数，有可能不出现</li>
</ul>
<h3 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h3><ul>
<li><p>贪婪匹配<br>eg. let regex= /\d{2, 5}/g,会匹配2位，3位，4位，5位连续数字, 但是是贪婪的，就是你有6位数字就匹配5位数字，有3位就匹配3位数字 </p>
</li>
<li><p>惰性匹配<br>eg. let regex= /\d{2, 5}?/g,表示2个的时候就已经够了，所以就停下来了， 当匹配两个的时候就不再往下尝试了<br>let regex = /\d{2,5}?/g;<br>let string = “123 1234 12345 123456”;<br>console.log( string.match(regex) );<br>// =&gt; [“12”, “12”, “34”, “12”, “34”, “12”, “34”, “56”]</p>
</li>
</ul>
<p>通过在量词后面加问号，就可以实现贪婪匹配</p>
<h2 id="多选分支"><a href="#多选分支" class="headerlink" title="多选分支"></a>多选分支</h2><p>支持多个子模式任选其一, (p1|p2|p3)，其中p1, p2, p3是子模式，用管道符分隔，表示其中任何之一。</p>
<p>注意的是分支结构也是惰性的，当匹配上了前面的，后面的就不再尝试了<br>var regex = /good|goodbye/g;<br>var string = “goodbye”;<br>console.log( string.match(regex) );<br>// =&gt; [“good”]</p>
<p>排除字符组 [^\:*&lt;&gt;|”?\r\n/] 来表示合法字符</p>
<h1 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h1><ul>
<li>^ 匹配开头</li>
<li><p>$ 匹配结尾<br>位置是可以替换成字符的，例如replace(/^|$/gm, ‘#’),把开头和结尾加上#号</p>
</li>
<li><p>\b 是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，和\w和$</p>
</li>
<li><p>\B 正好相反</p>
</li>
<li><p>(?=p)，其中p是一个子模式，即匹配p前面的位置</p>
</li>
<li>(?!p)，正好相反</li>
</ul>
<p>其实对于位置的理解，我们可以理解成空字符串””。</p>
<p>正则不匹配任何东西 /.^/ 正则要求匹配只有一个字符，但是该字符后面是开头，所以不可能存在</p>
<p>数字的千位分隔符表示法 /(?!^)(?=(\d{3})+$)/g</p>
<p>更加细化 /\B(?=(\d{3})+\b)/g</p>
<h1 id="正则表达式括号的作用"><a href="#正则表达式括号的作用" class="headerlink" title="正则表达式括号的作用"></a>正则表达式括号的作用</h1><p>括号最直接的作用就是括号内的正则是一个整体，即提供子表达式。</p>
<p>每一个括号可以使用RegExp这个全局对象的$1..$9来获取，前提是已经进行过正则操作</p>
<p>replace中函数可以用$</p>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>在正则本身里引用分组，但是只能引用之前出现的分组，即为反向引用。</p>
<p>即 \1 表示之前的第一个分组</p>
<p>分组后面有量词匹配最后一个捕获</p>
<p>注意一个特殊  非捕获括号 (?:p)</p>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h1 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h1><h1 id="正则表达式的构建"><a href="#正则表达式的构建" class="headerlink" title="正则表达式的构建"></a>正则表达式的构建</h1><ul>
<li>注意回溯问题就可以解决效率</li>
</ul>
<h1 id="正则表达式的编程"><a href="#正则表达式的编程" class="headerlink" title="正则表达式的编程"></a>正则表达式的编程</h1><p>希望在以后的工作中来补充。</p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/js/">js</a>
          
        </div>

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/js位操作符.html">
        <span class="next-text nav-default">js位操作符</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2018 -
    
    2019
    <span class="footer-author">lawliet & nier.</span>
    <span class="power-by">
        We can Fly.
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1"></script>

  </body>
</html>
